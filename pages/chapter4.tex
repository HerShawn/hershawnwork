% multiple1902 <multiple1902@gmail.com>
% intro.tex
% Copyright 2011~2012, multiple1902 (Weisi Dai)
% https://code.google.com/p/xjtuthesis/
%
% It is strongly recommended that you read documentations located at
%   http://code.google.com/p/xjtuthesis/wiki/Landing?tm=6
% in advance of your compilation if you have not read them before.
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Weisi Dai.
%

\chapter{基于二叉树搜索的文字检测方法}
\echapter{Text detection based on Binary Tree Search}

    \section{问题的提出}
    \esection{Questions Posed}

    \section{方法原理与步骤}
    \esection{Principle and Summary of The Method}



    \section{候选文字行的提取}
    \esection{Candidate text line's extraction}

        \subsection{统计边缘响应}
        \esubsection{Static Skeleton Response}

        首先提出统计边缘响应方法，用以增强文本与背景之间的响应强度差异。给定如图\ref{fig.c4_static_skeleton_response}(a) 所示的场景文字图像$g$，计算其统计边缘响应$s$ 的方式如算法\ref{alg:c4_static_skeleton_response} 所示：

        \begin{algorithm} \renewcommand{\algorithmicrequire}{\textbf{输入:}}	\renewcommand{\algorithmicensure}{\textbf{输出:}}
    	\caption{统计边缘响应}
    	\label{alg:c4_static_skeleton_response}
    	\begin{algorithmic}[1]
    		\REQUIRE 输入的场景文字图像$g$
    		\ENSURE 图$g$相对应的统计边缘响应$s$
            \STATE 在图$g$上利用基于边缘骨架切割的文字检测子得到粗略的定位结果：文字定位包围框集合$B$及其相应的置信度分数集合$C$
    		\REPEAT
            \STATE $rs:=\left\{ b \times c  |\,b \in B, c \in C\right\}$
            \STATE $s:=s\cup rs,B:=B / b,C:=C / c$
            \UNTIL{$B=\varnothing$}
    	\end{algorithmic}
        \end{algorithm}

        其中$rs$指代的是响应小块，它的底面积是1 个定位包围框$b$，而高是$b$对应的置信度分数$c$。将所有的这些响应小块$rs$堆叠在一起，就构成了如图\ref{fig.c4_static_skeleton_response}(b) 所示的统计边缘响应$s$。

        \begin{figure}[htbp]
        \begin{minipage}[t]{0.37\linewidth}
        \centering
        \includegraphics[width=\textwidth]{./figures/c4_img.jpg}
        \centerline{\small (a)粗略定位结果}
        \end{minipage}
        \begin{minipage}[t]{0.35\linewidth}
        \centering
        \includegraphics[width=\textwidth]{./figures/c4_static_skeleton_response.jpg}
        \centerline{\small (b)统计边缘响应}
        \end{minipage}
        \begin{minipage}[t]{0.25\linewidth}
        \centering
        \includegraphics[width=\textwidth]{./figures/c4_horizontal_projection.jpg}
        \centerline{\small (c)水平方向的映射}
        \end{minipage}
        \caption{在统计边缘响应中，文本区域与背景可以被区分开；而且通过后续的对统计边缘响应的水平映射操作，文本行也可以进一步区分开彼此}
        \label{fig.c4_static_skeleton_response}
        \end{figure}

        为了后续提取候选文本行的操作，首先要利用公式\ref{eq:c4_horizontal_projection} 来计算统计边缘响应$s$的横向投影$hp$，如图\ref{fig.c4_static_skeleton_response}(c) 所示。

        \begin{equation}
        hp= \left\{ \sum_{j=1}^w s_{ij} \, | \, i=1,2,...,h;j=1,2,...,w \right\},
        \label{eq:c4_horizontal_projection}
        \end{equation}

        其中，$h,w$分别是统计边缘响应$s$ 的高度和宽度。

        \subsection{候选文字行的生成}
        \esubsection{Text line's construction}

        在上1小节中得到了统计边缘响应$s$ 的横向投影$hp$,它的数值如图\ref{fig.c4_candidate_line_construction}(a) 中的蓝色曲线所示，从中可看出候选文本行之间的响应有着明显的起伏变化。

        \begin{figure}[htbp]
        \begin{minipage}[t]{0.32\linewidth}
        \centering
        \includegraphics[width=\textwidth]{./figures/c4_gradient.jpg}
        \centerline{\small (a)在水平映射图上的梯度}
        \end{minipage}
        \begin{minipage}[t]{0.32\linewidth}
        \centering
        \includegraphics[width=\textwidth]{./figures/c4_unified.jpg}
        \centerline{\small (b)梯度的取正和统一坐标}
        \end{minipage}
        \begin{minipage}[t]{0.32\linewidth}
        \centering
        \includegraphics[width=\textwidth]{./figures/c4_nms.jpg}
        \centerline{\small (c)梯度的非极大值抑制}
        \end{minipage}
        \caption{通过梯度计算和非极大值抑制操作来粗略定位文本行}
        \label{fig.c4_candidate_line_construction}
        \end{figure}

        为了确定候选文本行之间的分界线的具体位置，我们在统计边缘响应的横向投影$hp$上计算其梯度$g$,如图\ref{fig.c4_candidate_line_construction}(a) 中的脉冲状红线所示。梯度$g$表征着响应$hp$在某1 竖直位置上的变化程度：梯度$g$ 中的某1 脉冲状红线$l$的长度越大，就表明在红线$l$的附近越有可能存在着文字区域与背景区域之间的边界。而在梯度$g$中不存在脉冲红线的地方，意味着在这些区域的响应并没有发生突变，因此在$hp$上这些对应的位置上不存在文字区域与背景区域间的边界。

        为了便于观察和分析，首先对梯度值$g$取正，并将其提高至与$hp$统一的坐标内，如图\ref{fig.c4_candidate_line_construction}(b) 所示，这时得到的梯度值是$g$$'$。 最后在梯度值$g$$'$上执行非极大值抑制操作，由此消除掉绝大部分较小梯度值的无效脉冲状红线，并得到候选文本行集合$L$，而$L$由如图\ref{fig.c4_candidate_line_construction}(c) 中的$m$条红色候选文本行分割线组成。

    \section{二叉树型的文字行搜索空间的构建}
    \esection{Binary Tree-based search space's construction}

    将候选文本行集合$L$展现在场景文字原图上，如图\ref{fig.c4_binary_tree_construction}(b) 所示。$L$由$m$ 条红线$l_i, i=1,2,...,m$构成，这些红线是候选文本行分割线，并且在场景文字原图上分割出$m+1$个候选文本行条带，而这些文本行条带就是任两个相邻红线$l_i$和$l_{i+1}$ 之间的图像区域。那么现阶段的任务是，将所有候选文本行条带区域的排练组合作为1个搜索空间，然后从中搜寻出最优的文本行条带组合，而这些条带区域能恰如其分地覆盖住文字所在的图像区域。

    \begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./figures/c4_binary_tree_construction.jpg}
    \begin{minipage}[t]{0.40\linewidth}
    \centerline{\small (a)二叉树型搜索空间}
    \end{minipage}
    \begin{minipage}[t]{0.51\linewidth}
    \centerline{\small(b)在场景图像中的候选文本行}
    \end{minipage}
    \caption{从候选文本行中建立起代表搜索空间的二叉树型数据结构}
    \label{fig.c4_binary_tree_construction}
    \end{figure}

    假设红色分割线$l_i$有2个属性：距离$ld_i$和置信度$lc_i$。其中属性$ld_i$ 指代的是从图像顶部到分割线$l_i$ 位置的距离，例如在图\ref{fig.c4_binary_tree_construction}(b) 中，$ld_3=331_{px}$就是指从图像顶部到线$l_3$的距离有331个像素大小。而$lc_i$是分割线$l_i$的置信度，其数值是由$l_i$的梯度值归一化得到的，例如在图\ref{fig.c4_binary_tree_construction}(b) 中，$lc_3=0.987$ 表征的是$l_3$是文本行之间分割边界的可能性非常大。

    然后假设我们要构建的二叉树型搜索空间$N$是由一些结点$n$ 构成的。其中任一结点$n_i$有2个对应的属性：结点代表的图像区域范围$nr_i$，以及结点的数值$nv_i$。以图\ref{fig.c4_binary_tree_construction}(a) 为例，节点$n_5$ 所代表的文本行区域范围是从线$l_3$到$l_5$之间的区域，而$n_5$的值是由$l_4$ 的置信度值$lc_4$ 赋予的。

    在明确候选文本行分割线$L$，以及二叉树型搜索空间$N$中各变量的含义后，由$L$构建$N$的过程如算法\ref{alg:c4_build_binary_tree} 所示：

    \begin{algorithm}
	\renewcommand{\algorithmicrequire}{\textbf{输入:}}
	\renewcommand{\algorithmicensure}{\textbf{输出:}}
	\caption{递归地建立二叉树型搜索空间}
	\label{alg:c4_build_binary_tree}
	\begin{algorithmic}[1]
		\REQUIRE 分割线 $L$ 的距离 $LD=\left\{ld_1,ld_2,...,ld_m\right\}$ 和置信度$LC=\left\{lc_1,lc_2,...,lc_m\right\}$
		\ENSURE 二叉树型搜索空间 $N$ 的结点范围 $NR=\left\{nr_1,nr_2,...,nr_{2m-3}\right\}$, 和结点的值 $NV=\left\{nv_1,nv_2,...,nv_{2m-3}\right\}$
      \STATE 初始化: \\
      \STATE \quad $i=0, \quad BuildBinaryTree(i,LD,LC)$
      \STATE function $BuildBinaryTree(i,LD,LC)$
        \\\STATE \quad $i=i+1$
        \\\STATE \quad $if \quad length(LD)==2 \quad then$
        \\\STATE \qquad $nr_{i}=[LD[1],LD[2]], nv_{i}=0$
        \\\STATE \qquad $return$
        \\\STATE \quad $end \ if$
        \\\STATE \quad $nr_{i}=[LD[1],LD[end]], nv_{i}=max(LC)$
        \\\STATE \quad $//$假设$LC$中的最大值是$lc_t$，其中$t$是$lc_t$ 的索引
        \\\STATE \quad $//$在索引$t$处将$L$分裂成左子集和右子集
        \\\STATE \quad $LD_{l}=\left\{LD[1],...,LD[t]\right\}, LC_{l}=\left\{LC[1],...,LC[t]\right\}$
        \\\STATE \quad $BuildBinaryTree(i,LD_{l},LC_{l})$
        \\\STATE \quad $LD_{r}=\left\{LD[t],...,LD[end]\right\}, LC_{r}=\left\{LC[t],...,LC[end]\right\}$
        \\\STATE \quad $BuildBinaryTree(i,LD_{r},LC_{r})$
      \STATE end function
	\end{algorithmic}
    \end{algorithm}

    那么，通过算法\ref{alg:c4_build_binary_tree} 从$L$中构建好的二叉树型搜索空间$N$就将存储在如图中的表格内。下一节，将介绍从搜索空间$N$ 中搜寻出最优文本行定位的搜索策略。

    \section{搜索最优的文字行定位}
    \esection{Searching the optimal text detection}

        \subsection{搜索路径}
        \esubsection{Searching the paths}

        给定二叉树型搜索空间$N$,假设$N$是由$m$个结点$n$构成，那么通过算法\ref{alg:c4_search_path}，就可搜索出路径$P={p_1,p_2,...,p_{(m-1)/2}}$。 路径中的每个$p_i \in P$都是1个3元组：包含了父亲结点$np_i$，左子结点$nl_i$和右子结点$nr_i$。

        \begin{algorithm}
    	\renewcommand{\algorithmicrequire}{\textbf{输入:}}	
        \renewcommand{\algorithmicensure}{\textbf{输出:}}
    	\caption{从二叉树型搜索空间中找到最优路径}
    	\label{alg:c4_search_path}
    	\begin{algorithmic}[1]
    		\REQUIRE 二叉树型搜索空间 $N=\left\{n_1,n_2,...,n_m\right\}$， 其中每个结点$n_x \in N$有其相应的属性: 范围$nr_x$ 和值$nv_x$
    		\ENSURE 搜索到的路径 $P=\left\{p_1,p_2,...,p_{(m-1)/2}\right\}$， 其中每条路径$p_{i} \in P$ 包含结点三元组$p_{i}=\left\{np_{i},nl_{i},nr_{i}\right\}$

          \STATE 初始化: $idx=0$
          \FOR{$i=1$ to $(m-1)/2$}

          \FOR{$j=1$ to $m$}
          \IF{$nv_j$ == $leastPositive(NV)$}
          \STATE $np_i = n_j, nv_j = 0, idx = j$
          \ENDIF

          \IF{$nr_j[1]$ == $nr_{idx}[1]$ and $nv_j$ == $0$}
          \STATE $nl_i = n_j, nv_j = -1$
          \ENDIF

          \IF{$nr_j[2]$ == $nr_{idx}[2]$ and $nv_j$ == $0$}
          \STATE $nr_i = n_j, nv_j = -1$
          \ENDIF

          \ENDFOR

          \STATE $p_{i}$ = $\left\{ np_{i},nl_{i},nr_{i} \right\}$

          \ENDFOR
    	  \end{algorithmic}
        \end{algorithm}

        算法\ref{alg:c4_search_path}的具体过程如下所述：根据二叉树的性质，如果二叉树$N$中存在$m$个结点，那么算法\ref{alg:c4_search_path}就要迭代执行$(m-2)/2$次。在第$i$次迭代中，首先将具有最小正数值$nv_j \in NV$的结点$n_j \in N$，赋予路径三元组中的父亲结点$np_i$，

        \subsection{搜索策略}
        \esubsection{Searching strategies}

    \section{实验和结果分析}
    \esection{Experimental Results}

        \subsection{实验数据集与评价标准}
        \esubsection{Data-set and Evaluation Protocol}

        \subsection{实验结果与分析}
        \esubsection{Experimental Results and Analysis}

    \section{本章小结}
    \esection{Brief Summary}


